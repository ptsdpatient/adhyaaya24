{"compilerOptions":{"css":"external","dev":true,"hydratable":true},"configFile":false,"extensions":[".svelte"],"preprocess":[{"script":"async script({ attributes, content, filename = '' }) {\r\n\t\t\tconst lang = /** @type {string} */ (attributes.lang);\r\n\t\t\tif (!supportedScriptLangs.includes(lang)) return;\r\n\t\t\tconst { code, map } = await transformWithEsbuild(content, filename, {\r\n\t\t\t\tloader: /** @type {import('vite').ESBuildOptions['loader']} */ (lang),\r\n\t\t\t\ttarget: 'esnext',\r\n\t\t\t\ttsconfigRaw: {\r\n\t\t\t\t\tcompilerOptions: {\r\n\t\t\t\t\t\t// svelte typescript needs this flag to work with type imports\r\n\t\t\t\t\t\timportsNotUsedAsValues: 'preserve',\r\n\t\t\t\t\t\tpreserveValueImports: true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tmapToRelative(map, filename);\r\n\r\n\t\t\treturn {\r\n\t\t\t\tcode,\r\n\t\t\t\tmap\r\n\t\t\t};\r\n\t\t}","style":"async ({ attributes, content, filename = '' }) => {\r\n\t\tconst lang = /** @type {string} */ (attributes.lang);\r\n\t\tif (!supportedStyleLangs.includes(lang)) return;\r\n\t\tif (!transform) {\r\n\t\t\t/** @type {import('vite').ResolvedConfig} */\r\n\t\t\tlet resolvedConfig;\r\n\t\t\t// @ts-expect-error special prop added if running in v-p-s\r\n\t\t\tif (style.__resolvedConfig) {\r\n\t\t\t\t// @ts-expect-error\r\n\t\t\t\tresolvedConfig = style.__resolvedConfig;\r\n\t\t\t} else if (isResolvedConfig(config)) {\r\n\t\t\t\tresolvedConfig = config;\r\n\t\t\t} else {\r\n\t\t\t\tresolvedConfig = await resolveConfig(\r\n\t\t\t\t\tconfig,\r\n\t\t\t\t\tprocess.env.NODE_ENV === 'production' ? 'build' : 'serve'\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\ttransform = getCssTransformFn(resolvedConfig);\r\n\t\t}\r\n\t\tconst suffix = `${lang_sep}${lang}`;\r\n\t\tconst moduleId = `${filename}${suffix}`;\r\n\t\tconst { code, map, deps } = await transform(content, moduleId);\r\n\t\tremoveLangSuffix(map, suffix);\r\n\t\tmapToRelative(map, filename);\r\n\t\tconst dependencies = deps ? Array.from(deps).filter((d) => !d.endsWith(suffix)) : undefined;\r\n\t\treturn {\r\n\t\t\tcode,\r\n\t\t\tmap: map ?? undefined,\r\n\t\t\tdependencies\r\n\t\t};\r\n\t}"},{"defaultLanguages":{"markup":"html","style":"css","script":"javascript"},"markup":"async ({ content, filename }) => {\r\n        if (transformers.replace) {\r\n            const transformed = await (0, exports.transform)('replace', transformers.replace, {\r\n                content,\r\n                markup: content,\r\n                filename,\r\n            });\r\n            content = transformed.code;\r\n        }\r\n        return (0, markup_1.transformMarkup)({ content, filename }, markupTransformer, {\r\n            // we only pass the markupTagName because the rest of options\r\n            // is fetched internally by the `markupTransformer`\r\n            markupTagName,\r\n        });\r\n    }","script":"async ({ content, attributes, markup: fullMarkup, filename, }) => {\r\n        const transformResult = await scriptTransformer({\r\n            content,\r\n            attributes,\r\n            markup: fullMarkup,\r\n            filename,\r\n        });\r\n        let { code, map, dependencies, diagnostics } = transformResult;\r\n        if (transformers.babel) {\r\n            const transformed = await (0, exports.transform)('babel', getTransformerOptions('babel'), { content: code, markup: fullMarkup, map, filename, attributes });\r\n            code = transformed.code;\r\n            map = transformed.map;\r\n            dependencies = (0, utils_1.concat)(dependencies, transformed.dependencies);\r\n            diagnostics = (0, utils_1.concat)(diagnostics, transformed.diagnostics);\r\n        }\r\n        return { code, map, dependencies, diagnostics };\r\n    }","style":"async ({ content, attributes, markup: fullMarkup, filename, }) => {\r\n        const transformResult = await cssTransformer({\r\n            content,\r\n            attributes,\r\n            markup: fullMarkup,\r\n            filename,\r\n        });\r\n        let { code, map, dependencies } = transformResult;\r\n        const hasPostcss = await (0, utils_1.hasDepInstalled)('postcss');\r\n        // istanbul ignore else\r\n        if (hasPostcss) {\r\n            if (transformers.postcss) {\r\n                const { alias, lang } = (0, language_1.getLanguage)(attributes);\r\n                const postcssOptions = getTransformerOptions('postcss', (0, language_1.isAliasOf)(alias, lang) ? alias : null, \r\n                // todo: this seems wrong and ugly\r\n                { ignoreAliasOverride: true });\r\n                const transformed = await (0, exports.transform)('postcss', postcssOptions, {\r\n                    content: code,\r\n                    markup: fullMarkup,\r\n                    map,\r\n                    filename,\r\n                    attributes,\r\n                });\r\n                code = transformed.code;\r\n                map = transformed.map;\r\n                dependencies = (0, utils_1.concat)(dependencies, transformed.dependencies);\r\n            }\r\n            const transformed = await (0, exports.transform)('globalStyle', getTransformerOptions('globalStyle'), { content: code, markup: fullMarkup, map, filename, attributes });\r\n            code = transformed.code;\r\n            map = transformed.map;\r\n        }\r\n        else if ('global' in attributes) {\r\n            console.warn(`[svelte-preprocess] 'global' attribute found, but 'postcss' is not installed. 'postcss' is used to walk through the CSS and transform any necessary selector.`);\r\n        }\r\n        return { code, map, dependencies };\r\n    }"},{"script":"({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tif (basename.startsWith('+page.') || basename.startsWith('+layout.')) {\n\t\t\tconst match = content.match(options_regex);\n\t\t\tif (match) {\n\t\t\t\tconst fixed = basename.replace('.svelte', '(.server).js/ts');\n\n\t\t\t\tconst message =\n\t\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t\t`\\`${match[1]}\\` will be ignored — move it to ${fixed} instead. See https://kit.svelte.dev/docs/page-options for more information.`;\n\n\t\t\t\tif (!warned.has(message)) {\n\t\t\t\t\tconsole.log(message);\n\t\t\t\t\twarned.add(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","markup":"({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tif (basename.startsWith('+layout.') && !content.includes('<slot')) {\n\t\t\tconst message =\n\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t'`<slot />` missing — inner content will not be rendered';\n\n\t\t\tif (!warned.has(message)) {\n\t\t\t\tconsole.log(message);\n\t\t\t\twarned.add(message);\n\t\t\t}\n\t\t}\n\t}"}]}