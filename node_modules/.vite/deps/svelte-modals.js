import {
  writable
} from "./chunk-2ZCWYXCN.js";
import {
  SvelteComponentDev,
  assign,
  check_outros,
  claim_component,
  claim_space,
  component_subscribe,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  empty,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  group_outros,
  handle_promise,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  outro_and_destroy_block,
  safe_not_equal,
  set_store_value,
  space,
  transition_in,
  transition_out,
  update_await_block_branch,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-6KYLOQ6I.js";
import "./chunk-XNHBATJA.js";

// node_modules/svelte-modals/dist/store.js
var exitBeforeEnter = writable(false);
var transitioning = writable(null);
var modals = writable([]);
var action = writable(null);
function closeAllModals() {
  var _a, _b;
  const modalsLength = get_store_value(modals).length;
  const currentModal = get_store_value(modals)[modalsLength - 1];
  if ((_a = currentModal == null ? void 0 : currentModal.callbacks) == null ? void 0 : _a.onBeforeClose) {
    if (((_b = currentModal == null ? void 0 : currentModal.callbacks) == null ? void 0 : _b.onBeforeClose()) === false) {
      return false;
    }
  }
  modals.set([]);
  return true;
}
function closeModals(amount = 1) {
  var _a, _b;
  const modalsLength = get_store_value(modals).length;
  const currentModal = get_store_value(modals)[modalsLength - 1];
  if (get_store_value(transitioning)) {
    return false;
  }
  if ((_a = currentModal == null ? void 0 : currentModal.callbacks) == null ? void 0 : _a.onBeforeClose) {
    if (((_b = currentModal == null ? void 0 : currentModal.callbacks) == null ? void 0 : _b.onBeforeClose()) === false) {
      return false;
    }
  }
  if (get_store_value(exitBeforeEnter) && modalsLength > 0) {
    transitioning.set(true);
  }
  exitBeforeEnter.set(false);
  action.set("pop");
  pop(amount);
  return true;
}
function closeModal() {
  return closeModals(1);
}
function openModal(component, props, options) {
  if (get_store_value(transitioning)) {
    return;
  }
  action.set("push");
  if (get_store_value(exitBeforeEnter) && get_store_value(modals).length) {
    transitioning.set(true);
  }
  exitBeforeEnter.set(false);
  if (options == null ? void 0 : options.replace) {
    modals.update((prev) => [...prev.slice(0, prev.length - 1), { component, props }]);
  } else {
    modals.update((prev) => [...prev, { component, props }]);
  }
}
function onBeforeClose(callback) {
  modals.update((prev) => {
    const modal = prev[prev.length - 1];
    modal.callbacks = {
      ...modal.callbacks,
      onBeforeClose: callback
    };
    return prev;
  });
}
function pop(amount = 1) {
  modals.update((prev) => prev.slice(0, Math.max(0, prev.length - amount)));
}

// node_modules/svelte-modals/dist/Modals.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  child_ctx[11] = i;
  return child_ctx;
}
var get_loading_slot_changes = (dirty) => ({});
var get_loading_slot_context = (ctx) => ({});
var get_backdrop_slot_changes = (dirty) => ({});
var get_backdrop_slot_context = (ctx) => ({});
function create_if_block_1(ctx) {
  let current;
  const backdrop_slot_template = (
    /*#slots*/
    ctx[4].backdrop
  );
  const backdrop_slot = create_slot(
    backdrop_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_backdrop_slot_context
  );
  const block = {
    c: function create() {
      if (backdrop_slot)
        backdrop_slot.c();
    },
    l: function claim(nodes) {
      if (backdrop_slot)
        backdrop_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (backdrop_slot) {
        backdrop_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (backdrop_slot) {
        if (backdrop_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            backdrop_slot,
            backdrop_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              backdrop_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_backdrop_slot_changes
            ),
            get_backdrop_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(backdrop_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(backdrop_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (backdrop_slot)
        backdrop_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(13:0) {#if $modals.length > 0}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      isOpen: (
        /*i*/
        ctx[11] === /*$modals*/
        ctx[0].length - 1 && !/*$transitioning*/
        ctx[1]
      )
    },
    /*modal*/
    ctx[9].props
  ];
  var switch_value = (
    /*modal*/
    ctx[9].component
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on(
      "introstart",
      /*introstart_handler_1*/
      ctx[7]
    );
    switch_instance.$on(
      "outroend",
      /*outroend_handler_1*/
      ctx[8]
    );
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & /*$modals, $transitioning*/
      3 ? get_spread_update(switch_instance_spread_levels, [
        {
          isOpen: (
            /*i*/
            ctx2[11] === /*$modals*/
            ctx2[0].length - 1 && !/*$transitioning*/
            ctx2[1]
          )
        },
        dirty & /*$modals*/
        1 && get_spread_object(
          /*modal*/
          ctx2[9].props
        )
      ]) : {};
      if (dirty & /*$modals*/
      1 && switch_value !== (switch_value = /*modal*/
      ctx2[9].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          switch_instance.$on(
            "introstart",
            /*introstart_handler_1*/
            ctx2[7]
          );
          switch_instance.$on(
            "outroend",
            /*outroend_handler_1*/
            ctx2[8]
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(36:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let await_block_anchor;
  let promise;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 12,
    blocks: [, , ,]
  };
  handle_promise(promise = getComponent(
    /*modal*/
    ctx[9].component
  ), info);
  const block = {
    c: function create() {
      await_block_anchor = empty();
      info.block.c();
    },
    l: function claim(nodes) {
      await_block_anchor = empty();
      info.block.l(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & /*$modals*/
      1 && promise !== (promise = getComponent(
        /*modal*/
        ctx[9].component
      )) && handle_promise(promise, info)) {
      } else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < 3; i += 1) {
        const block2 = info.blocks[i];
        transition_out(block2);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(20:4) {#if isLazyModal(modal.component)}",
    ctx
  });
  return block;
}
function create_catch_block(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_catch_block.name,
    type: "catch",
    source: "(1:0) <script>   import { modals, exitBeforeEnter, transitioning }",
    ctx
  });
  return block;
}
function create_then_block(ctx) {
  let switch_instance;
  let t;
  let current;
  const switch_instance_spread_levels = [
    {
      isOpen: (
        /*i*/
        ctx[11] === /*$modals*/
        ctx[0].length - 1 && !/*$transitioning*/
        ctx[1]
      )
    },
    /*modal*/
    ctx[9].props
  ];
  var switch_value = (
    /*component*/
    ctx[12]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on(
      "introstart",
      /*introstart_handler*/
      ctx[5]
    );
    switch_instance.$on(
      "outroend",
      /*outroend_handler*/
      ctx[6]
    );
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & /*$modals, $transitioning*/
      3 ? get_spread_update(switch_instance_spread_levels, [
        {
          isOpen: (
            /*i*/
            ctx2[11] === /*$modals*/
            ctx2[0].length - 1 && !/*$transitioning*/
            ctx2[1]
          )
        },
        dirty & /*$modals*/
        1 && get_spread_object(
          /*modal*/
          ctx2[9].props
        )
      ]) : {};
      if (dirty & /*$modals*/
      1 && switch_value !== (switch_value = /*component*/
      ctx2[12])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          switch_instance.$on(
            "introstart",
            /*introstart_handler*/
            ctx2[5]
          );
          switch_instance.$on(
            "outroend",
            /*outroend_handler*/
            ctx2[6]
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, t.parentNode, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_then_block.name,
    type: "then",
    source: "(23:6) {:then component}",
    ctx
  });
  return block;
}
function create_pending_block(ctx) {
  let t;
  let current;
  const loading_slot_template = (
    /*#slots*/
    ctx[4].loading
  );
  const loading_slot = create_slot(
    loading_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_loading_slot_context
  );
  const block = {
    c: function create() {
      if (loading_slot)
        loading_slot.c();
      t = space();
    },
    l: function claim(nodes) {
      if (loading_slot)
        loading_slot.l(nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      if (loading_slot) {
        loading_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (loading_slot) {
        if (loading_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            loading_slot,
            loading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              loading_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_loading_slot_changes
            ),
            get_loading_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(loading_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loading_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (loading_slot)
        loading_slot.d(detaching);
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_pending_block.name,
    type: "pending",
    source: '(21:44)          <slot name=\\"loading\\" />       {:then component}',
    ctx
  });
  return block;
}
function create_each_block(key_1, ctx) {
  let first;
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*$modals*/
    1)
      show_if = null;
    if (show_if == null)
      show_if = !!isLazyModal(
        /*modal*/
        ctx2[9].component
      );
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(18:2) {#each $modals as modal, i (i)}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = (
    /*$modals*/
    ctx[0]
  );
  validate_each_argument(each_value);
  const get_key = (ctx2) => (
    /*i*/
    ctx2[11]
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*getComponent, $modals, $$scope, $transitioning, $exitBeforeEnter, isLazyModal*/
      15) {
        each_value = /*$modals*/
        ctx2[0];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(17:6)    ",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let t;
  let current;
  let if_block = (
    /*$modals*/
    ctx[0].length > 0 && create_if_block_1(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$modals*/
        ctx2[0].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$modals*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*$modals, $$scope, $transitioning, $exitBeforeEnter*/
        15)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function isLazyModal(component) {
  return typeof component.prototype === "undefined";
}
async function getComponent(component) {
  return component().then((res) => res.default);
}
function instance($$self, $$props, $$invalidate) {
  let $modals;
  let $transitioning;
  let $exitBeforeEnter;
  validate_store(modals, "modals");
  component_subscribe($$self, modals, ($$value) => $$invalidate(0, $modals = $$value));
  validate_store(transitioning, "transitioning");
  component_subscribe($$self, transitioning, ($$value) => $$invalidate(1, $transitioning = $$value));
  validate_store(exitBeforeEnter, "exitBeforeEnter");
  component_subscribe($$self, exitBeforeEnter, ($$value) => $$invalidate(2, $exitBeforeEnter = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modals", slots, ["backdrop", "loading", "default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Modals> was created with unknown prop '${key}'`);
  });
  const introstart_handler = () => {
    set_store_value(exitBeforeEnter, $exitBeforeEnter = true, $exitBeforeEnter);
  };
  const outroend_handler = () => {
    set_store_value(transitioning, $transitioning = false, $transitioning);
  };
  const introstart_handler_1 = () => {
    set_store_value(exitBeforeEnter, $exitBeforeEnter = true, $exitBeforeEnter);
  };
  const outroend_handler_1 = () => {
    set_store_value(transitioning, $transitioning = false, $transitioning);
  };
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    modals,
    exitBeforeEnter,
    transitioning,
    isLazyModal,
    getComponent,
    $modals,
    $transitioning,
    $exitBeforeEnter
  });
  return [
    $modals,
    $transitioning,
    $exitBeforeEnter,
    $$scope,
    slots,
    introstart_handler,
    outroend_handler,
    introstart_handler_1,
    outroend_handler_1
  ];
}
var Modals = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modals",
      options,
      id: create_fragment.name
    });
  }
};
var Modals_default = Modals;
export {
  Modals_default as Modals,
  action,
  closeAllModals,
  closeModal,
  closeModals,
  modals,
  onBeforeClose,
  openModal
};
//# sourceMappingURL=svelte-modals.js.map
